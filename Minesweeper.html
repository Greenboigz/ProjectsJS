<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Minesweeper</title>
</head>
<body>
<script>
/* Tile */
var TILE = 20;

/* Tile Types */
var EMPTY = 0, BOMB = -1;

/**
 * Game objects
 */
canvas,	  /* HTMLCanvas */
ctx,	  /* CanvasRenderingContext2d */
frames,   /* number, used for animation */
/**
 * Grid datastructor, usefull in games where the game world is
 * confined in absolute sized chunks of data or information.
 * 
 * @type {Object}
 */
grid = {
    ratio: null,  /* number, the number of columns */
    dim: null, /* number, the number of rows */
	_grid: null,  /* Array<any>, data representation */
  
	/**
	 * Initiate and fill a grid with the 
	 * @param  {float}    ratio   The percentage of mine tiles
	 * @param  {number}   dim     number of rows/columns
	 */
	init: function(ratio, dim) {
		this.ratio = ratio;
		this.dim = dim;
		this._grid = [];
		for (var x=0; x < dim; x++) {
			this._grid.push([]);
			for (var y=0; y < dim; y++) {
				this._grid[x].push(EMPTY);
			}
		}
        
        // Sets all the bombs
        for (var i=0; i < (dim^2)*ratio; i++) {
            var x = Math.random()%dim, y = Math.random()%dim;
            while (this.get(x,y) == BOMB) {
                x = Math.random()%dim; 
                y = Math.random()%dim;
            }
            this.set(BOMB, x, y);
        }
        
        // Sets all the bomb counts
        for (var x=0; x < dim; x++) {
			for (var y=0; y < dim; y++) {
				this.setBombCount(x,y);
			}
		}
	},
    
    /**
     * Sets the number of bombs surrounding a single tile
     *
     * @param {number} x    the x-coordinate
     * @param {number} y    the y-coordinate
     */
    setBombCount: function(x, y) {
        this.set(this.getBombCount(x,y),x,y);
    }
    
    /**
     * Gets the number of bombs surrounding a single tile
     *
     * @param {number} x    the x-coordinate
     * @param {number} y    the y-coordinate
     */
    getBombCount: function(x, y) {
        var count = 0;
        for (var i = -1; i < 2; i++) {
            for (var j = -1; i < 2; j++) {
                if ((i != 1 && j != 1) && this.get(i,j) == BOMB) {
                    count++;
                }
            }
        }
        return count;
    }
  
	/**
	 * Set the value of the grid cell at (x, y)
	 * 
	 * @param {any}    val what to set
	 * @param {number} x   the x-coordinate
	 * @param {number} y   the y-coordinate
	 */
	set: function(val, x, y) {
		this._grid[x][y] = val;
	},
  
	/**
	 * Get the value of the cell at (x, y)t
	 * 
	 * @param  {number} x the x-coordinate
	 * @param  {number} y the y-coordinate
	 * @return {any}   the value at the cell
	 */
	get: function(x, y) {
        if (x >= 0 && x < this.dim && y >= 0 && y < this.dim) {
		    return this._grid[x][y];
        } else {
            return 0;
        }
	}
}

/**
 * Starts the game
 */
function main() {
	// create and initiate the canvas element
	canvas = document.createElement("canvas");
	canvas.width = COLS*20;
	canvas.height = ROWS*20;
	ctx = canvas.getContext("2d");
	// add the canvas element to the body of the document
	document.body.appendChild(canvas);
	// sets an base font for bigger score display
	ctx.font = "12px Helvetica";
	frames = 0;
	keystate = {};
	// keeps track of the keybourd input
	document.addEventListener("keydown", function(evt) {
		keystate[evt.keyCode] = true;
	});
	document.addEventListener("keyup", function(evt) {
		delete keystate[evt.keyCode];
	});
	// intatiate game objects and starts the game loop
	init();
	loop();
}
/**
 * Resets and inits game objects
 */
function init() {
	score = 0;
	grid.init(EMPTY, COLS, ROWS);
	var sp = {x:Math.floor(COLS/2), y:ROWS-1};
	snake.init(UP, sp.x, sp.y);
	grid.set(SNAKE, sp.x, sp.y);
	setFood();
}
/**
 * The game loop function, used for game updates and rendering
 */
function loop() {
	update();
	draw();
	// When ready to redraw the canvas call the loop function
	// first. Runs about 60 frames a second
	window.requestAnimationFrame(loop, canvas);
}
/**
 * Updates the game logic
 */
function update() {
	frames++;
	// changing direction of the snake depending on which keys
	// that are pressed
	if (keystate[KEY_LEFT] && snake.direction !== RIGHT) {
		snake.direction = LEFT;
	}
	if (keystate[KEY_UP] && snake.direction !== DOWN) {
		snake.direction = UP;
	}
	if (keystate[KEY_RIGHT] && snake.direction !== LEFT) {
		snake.direction = RIGHT;
	}
	if (keystate[KEY_DOWN] && snake.direction !== UP) {
		snake.direction = DOWN;
	}
	// each five frames update the game state.
	if (frames%5 === 0) {
		// pop the last element from the snake queue i.e. the
		// head
		var nx = snake.last.x;
		var ny = snake.last.y;
		// updates the position depending on the snake direction
		switch (snake.direction) {
			case LEFT:
				nx--;
				break;
			case UP:
				ny--;
				break;
			case RIGHT:
				nx++;
				break;
			case DOWN:
				ny++;
				break;
		}
		// checks all gameover conditions
		if (0 > nx || nx > grid.width-1  ||
			0 > ny || ny > grid.height-1 ||
			grid.get(nx, ny) === SNAKE
		) {
			return init();
		}
		// check wheter the new position are on the fruit item
		if (grid.get(nx, ny) === FRUIT) {
			// increment the score and sets a new fruit position
			score++;
			setFood();
		} else {
			// take out the first item from the snake queue i.e
			// the tail and remove id from grid
			var tail = snake.remove();
			grid.set(EMPTY, tail.x, tail.y);
		}
		// add a snake id at the new position and append it to 
		// the snake queue
		grid.set(SNAKE, nx, ny);
		snake.insert(nx, ny);
	}
}
/**
 * Render the grid to the canvas.
 */
function draw() {
	// calculate tile-width and -height
	var tw = canvas.width/grid.width;
	var th = canvas.height/grid.height;
	// iterate through the grid and draw all cells
	for (var x=0; x < grid.width; x++) {
		for (var y=0; y < grid.height; y++) {
			// sets the fillstyle depending on the id of
			// each cell
			switch (grid.get(x, y)) {
				case EMPTY:
					ctx.fillStyle = "#fff";
					break;
				case SNAKE:
					ctx.fillStyle = "#0ff";
					break;
				case FRUIT:
					ctx.fillStyle = "#f00";
					break;
			}
			ctx.fillRect(x*tw, y*th, tw, th);
		}
	}
	// changes the fillstyle once more and draws the score
	// message to the canvas
	ctx.fillStyle = "#000";
	ctx.fillText("SCORE: " + score, 10, canvas.height-10);
}
	
// start and run the game
main();
</script>
</body>
</html>
