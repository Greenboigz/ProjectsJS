<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Minesweeper</title>
	
	<style>
	canvas {
		border: 1px solid #808080
		margin: auto;
	}
	</style>
</head>
<body>
<center><h1>Minesweeper</h1></center>
<div style="display:none">
	<img id="empty_tile" src="img/empty_tile.png">
	<img id="1_tile" src="img/1_tile.png">
	<img id="2_tile" src="img/2_tile.png">
	<img id="3_tile" src="img/3_tile.png">
	<img id="4_tile" src="img/4_tile.png">
	<img id="5_tile" src="img/5_tile.png">
	<img id="6_tile" src="img/6_tile.png">
	<img id="7_tile" src="img/7_tile.png">
	<img id="8_tile" src="img/8_tile.png">
	<img id="mine_tile" src="img/mine_tile.png">
	<img id="flag_tile" src="img/flag_tile.png">
	<img id="cover_tile" src="img/cover_tile.png">
	<img id="tripped_mine_tile" src="img/tripped_mine_tile.png">
	<img id="incorrect_flag_tile" src="img/incorrect_flag_tile.png">
</div>
<script>
/* 
TODO: (1) Add needed images (Red Mine, Wrongly Flagged, and Unsure Flag)
	  (2) Fix the image loading problem
	  (3) Can Win/Lose and Reset
*/

/* Tile */
var TILE = 20,
	DIM = 20,
	BAR = 1,
	RATIO = 0.05;
	
/* Tile Values */
var EMPTY = 0, 
	BOMB = -1;
	
/* Tile Visibilities */
var COVERED = 0,
	FLAGGED = 1,
	VISIBLE = 2;
	
/* Win States */
var WIN = 1,
	LOSS = -1;
			  
var SUR_TILES = [[-1,-1],[0,-1],[1,-1],
				 [-1,0],		[1,0],
				 [-1,1], [0,1],	[1,1]];

/* Tile Images of Numbers */
var IMAGES = ["empty_tile",
			  "1_tile",
			  "2_tile",
			  "3_tile",
			  "4_tile",
			  "5_tile",
			  "6_tile",
			  "7_tile",
			  "8_tile",
			  "mine_tile",
			  "flag_tile",
			  "cover_tile",
			  "tripped_mine_tile",
			  "incorrect_flag_tile"];
			  
/**
 * Game objects
 */
var canvas,	  /* HTMLCanvas */
	ctx,	  /* CanvasRenderingContext2d */
	frames,   /* number, used for animation */
/**
 * Grid datastructor, usefull in games where the game world is
 * confined in absolute sized chunks of data or information.
 * 
 * @type {Object}
 */
grid = {
    ratio: null,  /* number, the number of columns */
    dim: null, /* number, the number of rows */
	_value_grid: null,  /* Array<Array<number>>, data representation */
	_visible_grid: null, /* Array<Array<number>>, data representation */
	_win_state: null,
	_tripped_mine_tile: null,
  
	/**
	 * Initiate and fill a grid with the 
	 * @param  {float}    ratio   The percentage of mine tiles
	 * @param  {number}   dim     number of rows/columns
	 */
	init: function(ratio, dim) {
		this.dim = dim;
		this._ratio = ratio;
		this._value_grid = [];
		this._visible_grid = [];
		this._win_state = 0;
		this._images = [];
		this._tripped_mine_tile = [-1,-1];
		
		this.load_images();
				
		// Builds empty boards
		for (var x=0; x < dim; x++) {
			this._value_grid.push([]);
			this._visible_grid.push([]);
			for (var y=0; y < dim; y++) {
				this._value_grid[x].push(EMPTY);
				this._visible_grid[x].push(COVERED);
			}
		}
        
        // Sets all the bombs
        for (var i=0; i < Math.floor((dim*dim)*ratio); i++) {
            var x = Math.floor(Math.random()*dim), y = Math.floor(Math.random()*dim);
            while (this.get(x,y) == BOMB) {
                x = Math.floor(Math.random()*dim); 
                y = Math.floor(Math.random()*dim);
            }
            this.set(BOMB, x, y);
        }
        
        // Sets all the bomb counts
        for (var x=0; x < dim; x++) {
			for (var y=0; y < dim; y++) {
				this.setBombCount(x,y);
			}
		}
	},
	
	/**
	 * Loads all the images
	 */
	load_images: function() {
		for (var i=0; i<IMAGES.length; i++) {
			if (this._images[i] == null) {
				this._images[i] = document.getElementById(IMAGES[i]);
				//while (!this._images[i].complete);
			}
		}
	},
    
	/**
	 * Sets the number of bombs surrounding a single tile
	 *
	 * @param {number} x    the x-coordinate
	 * @param {number} y    the y-coordinate
	 */
	setBombCount: function(x, y) {
		if (this.get(x,y) != BOMB) {
			var val = this.getBombCount(x,y);
			this.set(val,x,y);
		}
	},
	
	/**
	 * Gets the number of bombs surrounding a single tile
	 *
	 * @param {number} x    the x-coordinate
	 * @param {number} y    the y-coordinate
	 */
	getBombCount: function(x, y) {
		var count = 0;
		for (var i = 0; i<SUR_TILES.length; i++) {
			count += (this.get(x+SUR_TILES[i][0],y+SUR_TILES[i][1]) == BOMB);
		}
		return count;
	},
	
	/**
	 * Gets the number of flags surrounding a single tile
	 *
	 * @param {number} x    the x-coordinate
	 * @param {number} y    the y-coordinate
	 */
	getFlagCount: function(x, y) {
		var count = 0;
		for (var i = 0; i<SUR_TILES.length; i++) {
			count += (this.get_visibility(x+SUR_TILES[i][0],y+SUR_TILES[i][1]) == FLAGGED);
		}
		return count;
	},
  
	/**
	 * Set the value of the grid cell at (x, y)
	 * 
	 * @param {any}    val what to set
	 * @param {number} x   the x-coordinate
	 * @param {number} y   the y-coordinate
	 */
	set: function(val, x, y) {
		if (x >= 0 && x < this.dim && y >= 0 && y < this.dim) {
		    this._value_grid[x][y] = val;
        }
	},
  
	/**
	 * Get the value of the cell at (x, y)
	 * 
	 * @param  {number} x the x-coordinate
	 * @param  {number} y the y-coordinate
	 * @return {any}   the value at the cell
	 */
	get: function(x, y) {
        if (x >= 0 && x < this.dim && y >= 0 && y < this.dim) {
		    return this._value_grid[x][y];
        } else {
            return EMPTY;
        }
	},
	
	/**
	 * Set the visibility of the grid cell at (x, y)
	 * 
	 * @param {any}    val what to set
	 * @param {number} x   the x-coordinate
	 * @param {number} y   the y-coordinate
	 */
	set_visibility: function(val, x, y) {
		if (x >= 0 && x < this.dim && y >= 0 && y < this.dim) {
		    this._visible_grid[x][y] = val;
        }
	},
  
	/**
	 * Get the visibility of the cell at (x, y)
	 * 
	 * @param  {number} x the x-coordinate
	 * @param  {number} y the y-coordinate
	 * @return {any}   the visibility at the cell
	 */
	get_visibility: function(x, y) {
        if (x >= 0 && x < this.dim && y >= 0 && y < this.dim) {
		    return this._visible_grid[x][y];
        } else {
            return null;
        }
	},
	
	/**
	 * Flags the tile at the given coordinate (x,y)
	 * @param  {number} x the x-coordinate
	 * @param  {number} y the y-coordinate
	 */
	flag: function(x,y) {
		if (this.get_visibility(x,y) == COVERED) {
			this.set_visibility(FLAGGED,x,y);
		} else if (this.get_visibility(x,y) == FLAGGED) {
			this.set_visibility(COVERED,x,y);
		}
	},
	
	/**
	 * Reveals the value hidden in a covered tile
	 * @param  {number} x the x-coordinate
	 * @param  {number} y the y-coordinate
	 */
	sweep: function(x, y) {
		if (this.get_visibility(x,y) == COVERED) {
			this.set_visibility(VISIBLE,x,y);
			if (this.get(x, y) == BOMB) {
				this.lose(x, y);
			} else if (this.get(x, y) == EMPTY) {
				for (var i = 0; i<SUR_TILES.length; i++) {
					this.sweep(x+SUR_TILES[i][0],y+SUR_TILES[i][1]);
				}
			} 
		} else if (this.get_visibility(x, y) == VISIBLE && 
				   this.get(x, y) != EMPTY &&
				   this.get(x, y) == this.getFlagCount(x, y)) {
			for (var i = 0; i<SUR_TILES.length; i++) {
				var xx = x+SUR_TILES[i][0], yy = y+SUR_TILES[i][1];
				if (this.get_visibility(xx,yy) == COVERED) {
					this.sweep(xx, yy);
				}
			}
		}
	},
	
	/**
	 * Reveals the whole board because a loss has occured
	 */
	lose: function(x, y) {
		this._tripped_mine_tile = [x,y];
		for (var i = 0; i < this.dim; i++) {
			for (var j = 0; j < this.dim; j++) {
				if (this.get(i,j) == BOMB && this.get_visibility(i,j) == COVERED) {
					this.set_visibility(VISIBLE,i,j);
				}
			}
		}
		this._win_state = LOSS;
	},
	
	/**
	 * Checks is the game is a loss
	 * @return {boolean} Is the board a loss
	 */
	is_loss: function() {
		return this._win_state == LOSS;
	},
	
	/**
	 * Checks is the game is a win
	 * @return {boolean} Is the board a win
	 */
	is_win: function() {
		return this._win_state == WIN;
	},
	
	/**
	 * Get the image file of the cell at (x, y)
	 *
	 * @param  {number} x the x-coordinate
	 * @param  {number} y the y-coordinate
	 * @return {image}   the image file at the cell
	 */ 
	get_image: function(x, y) {
		var img;
		switch (this.get_visibility(x,y)) {
			case COVERED:
				img = this._images[11];
				break;
			case FLAGGED:
				if (this.is_loss() && this.get(x,y) != BOMB) {
					img = this._images[13];
				} else {
					img = this._images[10];
				}
				break;
			default:
				switch (this.get(x,y)) {
					case BOMB:
						if (x == this._tripped_mine_tile[0] &&
							y == this._tripped_mine_tile[1]) {
							img = this._images[12];
						} else {
							img = this._images[9];
						}
						break;
					default:
						img = this._images[this.get(x,y)]
						break;
				}
				break;
		}
		return img;
	},
	
	/**
	 * Gets the string representation of the grid
	 */
	print: function() {
		var str = "";
		for (var y=0; y<this.dim; y++) {
			for (var x=0; x<this.dim; x++) {
				str += this.get(x,y);
				if (x != this.dim-1) {
					str += ",";
				} else {
					console.log(str);
					str = "";
				}
			}
		}
	}
}

/**
 * Starts the game
 */
function main() {
	// create and initiate the canvas element
	canvas = document.createElement("canvas");
	
	canvas.width = (DIM+BAR)*TILE+BAR;
	canvas.height = (DIM+BAR)*TILE+BAR;
	ctx = canvas.getContext("2d");
	// add the canvas element to the body of the document
	document.body.appendChild(canvas);
	// sets an base font for bigger score display
	ctx.font = "15px Helvetica";
	
	canvas.oncontextmenu = function (e) {
		e.preventDefault();
	};
	
	frames = 0;
	
	// intatiate game objects and starts the game loop
	init();
	loop();
	console.log("Main Finish");
}

/**
 * Resets and inits game objects
 */
function init() {
	var ratio = 0.15;
	grid.init(ratio, DIM);
	
	document.body.addEventListener("mouseup", canvasTouch);
}

/**
 * Handles Click events on the minesweeper canvas
 */
function canvasTouch(event) {
    var rect = canvas.getBoundingClientRect();
    var x = Math.floor((event.clientX - rect.left) / grid.dim);
    var y = Math.floor((event.clientY - rect.top) / grid.dim);
    
	if (!grid.is_loss() && !grid.is_win()) {
		if (event.button == 0 || event.button == 1) {
			grid.sweep(x,y);
		} else if (event.button == 2) {
			grid.flag(x,y);
		}
	}
	
	draw();
}

/**
 * The game loop function, used for game updates and rendering
 */
function loop() {
	update();
	draw();
	// When ready to redraw the canvas call the loop function
	// first. Runs about 60 frames a second
	//window.requestAnimationFrame(loop, canvas);
}
	
/**
 * Updates the game logic
 */
function update() {
	frames++;
}

/**
 * Render the grid to the canvas.
 */
function draw() {
	for (var x=0; x < grid.dim; x++) {
		for (var y=0; y < grid.dim; y++) {
			ctx.fillStyle = "#f00";
			var img = grid.get_image(x,y);
			ctx.drawImage(img, x*TILE, y*TILE, TILE, TILE);
		}
	}
	/*
	ctx.fillStyle = "#e0e0e0";
	ctx.fillRect(0,0,(DIM+BAR)*TILE+BAR,(DIM+BAR)*TILE+BAR);
	
	// iterate through the grid and draw all cells
	for (var x=0; x < grid.dim; x++) {
		for (var y=0; y < grid.dim; y++) {
			// sets the fillstyle depending on the id of
			// each cell
			switch (grid.get(x, y)) {
				case BOMB:
					ctx.fillStyle = "#f00";
					ctx.fillRect(BAR+x*(TILE+BAR), BAR+y*(TILE+BAR), TILE, TILE);
					break;
				case EMPTY:
					ctx.fillStyle = "#D3D3D3";
					ctx.fillRect(BAR+x*(TILE+BAR), BAR+y*(TILE+BAR), TILE, TILE);
					break;
				default:
					ctx.fillStyle = COLORS[grid.get(x,y)];
					ctx.fillText(grid.get(x,y), BAR+(x+0.25)*(TILE+BAR), BAR+(y+0.75)*(TILE+BAR));
					break;
			}
		}
	}
	
	for (var x=0; x <= grid.dim; x++) {
		ctx.fillStyle = "#000"
		ctx.fillRect(x*(TILE+BAR), 0, BAR, BAR+grid.dim*(TILE+BAR));
		ctx.fillRect(0, x*(TILE+BAR), BAR+grid.dim*(TILE+BAR), BAR);
	}
	*/
}
	
// start and run the game
main();
</script>
</body>
</html>
